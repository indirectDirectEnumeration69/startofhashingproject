// HashAlgorithmfordataencryption.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <algorithm>;
#include <math.h>;
#include <ymath.h>;
#include <unordered_set>;
//internet encryption key for sha256


static class Key {
	virtual void encryptKey() = 0;
};
	class KeyGeneration:Key {
	private:
		template <typename F>
		static const F key; //param keynow1 will be slightly insecure actually alot change this asap lol-me again ernest the idiot!
	public:template <typename A1>
		
		std::string encryptionKey( A1 keynow1) {
			{ 
				A1 keynow;  //never access key variable until keynow has been encrypted then pass to key variable;
				 keynow = "";
				std::cout << "Enter a key for encryption: ";
				std::cin >> keynow;
				keynow1 = keynow;
				if (keynow != keynow1) {
					delete& keynow;
					delete& keynow1;
					delete&* this; //probably does the same thing but might as well
					delete this;
				}
				//do something here to encrypt keynow1
				return keynow1;
			}
		}
	};
	class Hash {
		template <typename T>
		T Hashagain() { //method to hash again if hash is not secure enough for encryption
			{
				virtual T HashingResult();
			}
		}
	};


	class Hashing :Hash {
	protected:

		void Hashagain();

	};
		 //template for hash function
	class Hashcontainer {
	protected:
		static class Hashalgopart1 {
			virtual void algo1() = 0;
			virtual void mix() = 0;
			virtual int roundcount() = 0;
			virtual std::string roundgeneration() = 0;
		};
		class Hashingcapture :Hash {
			template <typename T>
			int HashingResult() {
				{
					T HashingResult;
					HashingResult = nullptr;
					std::cout << "Enter a string to hash: ";
					std::cin >> HashingResult;
					return HashingResult;
				}
			}
		private:
			class Hashsector :Hashalgopart1 {
				Hash* HashingResult() {
					Hash* hash = new Hash();
					return hash;
				}
			};
			class HashSecurity {
			private:

			public:
				Hashingcapture* hashthekey() {

				}
			};
		};
		class Singlecall :Hashingcapture {
		public:
			static Singlecall* const singleton;
		private:
			Singlecall(void) {}
			Singlecall(const Singlecall&);
			Singlecall& operator=(const Singlecall&);
		};
	};
#define keyvaluecheck
#if defined(keyvaluecheck);
#endif !=0;
#define keyvaluecheck 0000000;
#ifndef keyvaluecheck 1||>0;
#endif >0;
	 
	int main()
	{
		const struct HashStructure
		{
		public:
			double key = keyvaluecheck;
			//maybe use generic instead of static explicit types for more obfuscation;
			long hash = 0;


		}StorageSecure{};//however explicit types are easier to work with


		struct Sec :HashStructure {
		private:
			virtual int callHashing() = 0;
		};
		static KeyGeneration* keyA{};

		std::string keyval;
		std::string hh = keyA->encryptionKey<std::string>(keyval); //encrypt the key holder;
		// hh holds data for now.
		//secure this lambda

		auto hash = [](std::string const& s) {
			std::hash<std::string> hash;
			return hash(s);
		};
		std::cout << "Hashed key as hh: " << hash;
		std::cout << "'\nkey will now enter more levels of encyrption'\n";
		//key val now needs to be copied into keyval
		keyval = hash(hh);
		if (keyval != "") {
			// hh;
		}
		else { 
			auto key_ = [StorageSecure]() { //alll will be refactored into headers and cpp files temp lambdas for now but will be used when needed
				auto _key = StorageSecure.key;

				double& kn = _key;

				//simple just for experimenting with probability and certainty of values for longer guesses needed!.
				//this is the non hash function stuff for simple maths to build up from.
				// 
				//NEED TO SORT OUT DELETE LOGIC.
				for (auto as = 0; as < 10 * (sizeof(kn) % 2 * kn); as++) {
					kn = (0x22 * static_cast<unsigned long long>(as) ^ 2902) % (long&)StorageSecure - (int&)as % sizeof(malloc(_key));
					//now pass kn into a algorithm may be slow asf but who caress. thats refactoring shit.
					auto scramble = [kn]() {
						long double scramblekn = kn;
						switch (scramblekn != 0) {
							case sizeof(kn) < sizeof(scramblekn) :
								struct memory {
								virtual long double memoryallocation() = 0;
								virtual::double_t Swish() = 0;
							};

							struct locmem :memory {
							private:
								long double memoryallocation() {
									long double Now;
									if (!0) {

									}
									if (NULL || !nullptr) {//never be nullptr but it will be in future and evaluated before the creation of Now and used logixally some how.
										Now = 0;
									}			//experiemental lambdas will all be changed just early build!..
									else {// need to refactor for zero  semantic errors!!!
										//compiles fine for now until deeper use/implementation of function and setting.
										auto mix = [Now](auto q8202) {
											uint64_t keynumber = q8202; //binary bit 64
											q8202* keynumber = q8202;
											keynumber% q8202 = keynumber;
											auto temp = keynumber;
											delete keynumber;
											double long keynumber = temp ^= ((uint64_t)temp ^= temp % ((int&)temp &= temp)) ^ ((long&)temp %= ++sizeof(temp));
											keynumber = q8202 * keynumber;
											for (int a = 0; a < keynumber; a++) {
												keynumber = keynumber ^ 1.3782929;
												a >= 20 / sizeof(a * keynumber) ? a + keynumber = Now : a++;
												if (Now != 0 && Now > 120000) {
													return Now;
												};
											}
										};
									}
								}
							};

						}
					};

				}
				return _key;
			};
		};
		delete keyA;
		std::cout << "This is the key value for now: " << keyval;
		static Hashing* KeyB{};
		switch (hh.size() || hh.empty() != 0) {
			delete& keyval;
		}
	}



		//after key is passed to next function delete all the variables not going to be used;
		//always keep changing the variable holding the next value to be passed to the next function;
		//so no static location for security
		//immbeded layers of encryption needed.....
