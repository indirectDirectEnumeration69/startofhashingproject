// HashAlgorithmfordataencryption.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <algorithm>;
#include <math.h>;
#include <ymath.h>;
//internet encryption key for sha256


static class Key {
	virtual void encryptKey() = 0;
};
	class KeyGeneration:Key {
	private:
		template <typename F>
		static const F key; //param will be slightly insecure actually alot change this asap lol-me again ernest the idiot!
	public:template <typename A1>
		
		std::string encryptionKey( A1 keynow1) {
			{ 
				A1 keynow;  //never access key variable until keynow has been encrypted then pass to key variable;
				 keynow = "";
				std::cout << "Enter a key for encryption: ";
				std::cin >> keynow;
				keynow1 = keynow;
				if (keynow != keynow1) {
					delete& keynow;
					delete& keynow1;
					delete&* this; //probably does the same thing but might as well
					delete this;
				}
				//do something here to encrypt keynow1
				return keynow1;
			}
		}
	};
	class Hash {
		template <typename T>
		T Hashagain() { //method to hash again if hash is not secure enough for encryption
			{
				virtual T HashingResult();
			}
		}
	};


	class Hashing :Hash {
	protected:

		void Hashagain();

	};
		 //template for hash function
	class Hashcontainer {
	protected:
		static class Hashalgopart1 {
			virtual void algo1() = 0;
			virtual void mix() = 0;
			virtual int roundcount() = 0;
			virtual std::string roundgeneration() = 0;
		};
		class Hashingcapture :Hash {
			template <typename T>
			int HashingResult() {
				{
					T HashingResult;
					HashingResult = nullptr;
					std::cout << "Enter a string to hash: ";
					std::cin >> HashingResult;
					return HashingResult;
				}
			}
		private:
			class Hashsector :Hashalgopart1 {
				Hash* HashingResult() {
					Hash* hash = new Hash();
					return hash;
				}
			};
			class HashSecurity {
			private:

			public:
				Hashingcapture* hashthekey() {

				}
			};
		};
		class Singlecall :Hashingcapture {
		public:
			static Singlecall* const singleton;
		private:
			Singlecall(void) {}
			Singlecall(const Singlecall&);
			Singlecall& operator=(const Singlecall&);
		};
	};
#define keyvaluecheck
#if defined(keyvaluecheck);
#endif !=0;
#define keyvaluecheck 0000000;
#ifndef keyvaluecheck 1||>0;
#endif >0;
	int main()
	{
		const struct HashStructure
		{
		protected:
			double key = keyvaluecheck;
							//maybe use generic instead of static explicit types for more obfuscation;
			long hash;


		}StorageSecure;//however explicit types are easier to work with


		struct Sec :HashStructure {
		private:
			virtual int callHashing() = 0;
		};
			static KeyGeneration* keyA{};
			std::string keyval;
			std::string hh = keyA->encryptionKey<std::string>(keyval);
			keyA;
			std::cout << "This is the final key value: " << hh;
			delete keyA;
			switch (keyval.size() || keyval.empty() != 0) {
				delete& keyval;
			}
		}



		//after key is passed to next function delete all the variables not going to be used;
		//always keep changing the variable holding the next value to be passed to the next function;
		//so no static location for security
		//immbeded layers of encryption needed.....
