// HashAlgorithmfordataencryption.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <algorithm>;
#include <math.h>;
#include <ymath.h>;
//internet encryption key for sha256


static class Key {
	virtual void encryptKey() = 0;
};
	class KeyGeneration:Key {
	private:
		template <typename F>
		static const F key; //param will be slightly insecure actually alot change this asap lol-me again ernest the idiot!
	public:template <typename A1>
		
		std::string encryptionKey( A1 keynow1) {
			{ 
				A1 keynow;  //never access key variable until keynow has been encrypted then pass to key variable;
				 keynow = "";
				std::cout << "Enter a key for encryption: ";
				std::cin >> keynow;
				keynow1 = keynow;
				if (keynow != keynow1) {
					delete& keynow;
					delete& keynow1;
					delete&* this; //probably does the same thing but might as well
					delete this;
				}
				//do something here to encrypt keynow1
				return keynow1;
			}
		}
	};
	class Hash {
		template <typename T>
		T Hashagain() { //method to hash again if hash is not secure enough for encryption
			{
				virtual T HashingResult();
			}
		}
	};


	class Hashing :Hash {
	protected:

		void Hashagain();

	};
		 //template for hash function
	class Hashcontainer {
	protected:
		static class Hashalgopart1 {
			virtual void algo1() = 0;
			virtual void mix() = 0;
			virtual int roundcount() = 0;
			virtual std::string roundgeneration() = 0;
		};
		class Hashingcapture :Hash {
			template <typename T>
			int HashingResult() {
				{
					T HashingResult;
					HashingResult = nullptr;
					std::cout << "Enter a string to hash: ";
					std::cin >> HashingResult;
					return HashingResult;
				}
			}
		private:
			class Hashsector :Hashalgopart1 {
				Hash* HashingResult() {
					Hash* hash = new Hash();
					return hash;
				}
			};
			class HashSecurity {
			private:

			public:
				Hashingcapture* hashthekey() {

				}
			};
		};
		class Singlecall :Hashingcapture {
		public:
			static Singlecall* const singleton;
		private:
			Singlecall(void) {}
			Singlecall(const Singlecall&);
			Singlecall& operator=(const Singlecall&);
		};
	};
#define keyvaluecheck
#if defined(keyvaluecheck);
#endif !=0;
#define keyvaluecheck 0000000;
#ifndef keyvaluecheck 1||>0;
#endif >0;

	int main()
	{
		const struct HashStructure
		{
		public:
			double key = keyvaluecheck;
			//maybe use generic instead of static explicit types for more obfuscation;
			long hash = 0;


		}StorageSecure{};//however explicit types are easier to work with


		struct Sec :HashStructure {
		private:
			virtual int callHashing() = 0;
		};
		static KeyGeneration* keyA{};
		std::string keyval;
		std::string hh = keyA->encryptionKey<std::string>(keyval); //encrypt the key holder;
		// hh holds data for now.
		//secure this lambda
		auto key_ = [StorageSecure]() {
			
			




			auto _key = StorageSecure.key;

			double& kn = _key;
			
			//simple just for experimenting with probability and certainty of values for longer guesses needed!.
			//this is the non hash function stuff for simple maths to build up from.

			for (auto as = 0; as < 10*(sizeof(kn)%2*kn); as++) {
				kn = (0x22 * static_cast<unsigned long long>(as) ^ 2902) % (long&)StorageSecure - (int&)as % sizeof(malloc(_key));
				//now pass kn into a algorithm may be slow asf but who caress. thats refactoring shit.
				auto scramble = [kn]() {
					long double scramblekn = kn;
					switch (scramblekn != 0) {
						case sizeof(kn)<sizeof(scramblekn):

					
					}
				};
	
			}
			return _key;
		};
		 
		 

		delete keyA;
		std::cout << "This is the key value for now: " << hh;
		static Hashing* KeyB{};
		hh;
		switch (hh.size() || hh.empty() != 0) {
			delete& keyval;
		}

	}



		//after key is passed to next function delete all the variables not going to be used;
		//always keep changing the variable holding the next value to be passed to the next function;
		//so no static location for security
		//immbeded layers of encryption needed.....
